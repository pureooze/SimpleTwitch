@inject IConfiguration Configuration
@inject ITwitchService TwitchService

@page "/"
@using Microsoft.Extensions.Configuration
@using SimpleTwitch.Components.Layout
@using TwitchEverywhere.Core.Types.Messages.Implementation
@using TwitchEverywhere.Core.Types.Messages.Interfaces
@using SimpleTwitch.Services
@using TwitchEverywhere.Core.Types
@using TwitchEverywhere.Core.Types.RestApi.Wrappers
@using System.Net

<div>
    <div class="header">
        <div class="header-title-container">
            <img alt="" class="profile-image" src="@m_profileImageUrl"/>
            <h2>@m_displayName</h2>
        </div>
        <div class="input-container">
            <input class="user-input" @bind="m_input" @bind:event="oninput" @onkeyup="HandleEnterPressed"/>
        </div>
    </div>
    <div class="stream-page-content">
        <div class="video">
        </div>

        <div class="chat-container">
            <div class="chat">
                <div class="chat-wrapper">
                    @foreach (IPrivMsg message in m_messages.Reverse()) {
                        <ChatMessage Message="@message"></ChatMessage>
                    }
                </div>
            </div>
            <div class="chat-input-container">
                <textarea class="chat-input" type="text" placeholder="Send a message"></textarea>
                <button class="chat-send-button">Send</button>
            </div>
        </div>

    </div>
</div>

@code {
    private readonly Queue<IPrivMsg> m_messages = new();
    private int m_batchSize = 100;
    private ITwitchService m_service;
    private string m_input = "Cohh";
    private string m_displayName = "Cohh";
    private string m_profileImageUrl = "";

    protected override async Task OnInitializedAsync() {
        m_batchSize = Configuration.GetValue<int>( "Settings:BufferSize" );
        m_service = TwitchService;

        await m_service.ConnectToIrcChannel( channel: m_displayName.ToLower(), MessageCallback );
    }

    private void MessageCallback(
        IMessage message
    ) {
        switch( message.MessageType ) {
            case MessageType.PrivMsg:
                if( m_messages.Count > m_batchSize ) {
                    m_messages.Dequeue();
                }

                m_messages.Enqueue( (PrivMsg)message );
                StateHasChanged();
                break;
        }

    }
    
    private async Task HandleEnterPressed(KeyboardEventArgs e) {
        if(e.Code == "Enter" || e.Key == "Enter") {
            await HandleChannelChange();
        }
    }

    private async Task HandleChannelChange() {
        m_messages.Clear();

        GetUsersResponse response = await m_service.GetUsers( m_input.ToLower() );
        if( response.StatusCode == HttpStatusCode.OK ) {
            m_displayName = response.ApiResponse.Data[0].DisplayName;
            m_profileImageUrl = response.ApiResponse.Data[0].ProfileImageUrl;
            await m_service.DisconnectFromIrcChannel();
            await m_service.ConnectToIrcChannel( m_input, MessageCallback );
        }

        StateHasChanged();
    }
}