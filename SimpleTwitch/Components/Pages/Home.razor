@inject IConfiguration Configuration
@inject ITwitchService TwitchService
@inject EventService EventService

@page "/"
@using Microsoft.Extensions.Configuration
@using SimpleTwitch.Components.Layout
@using TwitchEverywhere.Core.Types.Messages.Implementation
@using TwitchEverywhere.Core.Types.Messages.Interfaces
@using SimpleTwitch.Services
@using TwitchEverywhere.Core.Types
@using TwitchEverywhere.Core.Types.RestApi.Wrappers
@using System.Net

<div>
    <h1>@m_displayName</h1>
    <div class="stream-page-content">
        <div class="video">
        </div>

        <div class="chat-container">
            <div class="chat">
                <div class="chat-wrapper">
                    @foreach (IPrivMsg message in m_messages.Reverse()) {
                        <ChatMessage Message="@message"></ChatMessage>
                    }
                </div>
            </div>
            <div class="chat-input-container">
                <textarea class="chat-input" type="text" placeholder="Send a message"></textarea>
                <button class="chat-send-button">Send</button>
            </div>
        </div>

    </div>
</div>

@code {
    private readonly Queue<IPrivMsg> m_messages = new();
    private int m_batchSize = 100;
    private ITwitchService m_service;
    private string m_displayName = "Cohh";

    protected override async Task OnInitializedAsync() {
        m_batchSize = Configuration.GetValue<int>( "Settings:BufferSize" );
        m_service = TwitchService;

        EventService.OnEnterPressed += async (sender, args) => await HandleEnterPressed(args);
        await m_service.ConnectToIrcChannel( channel: m_displayName.ToLower(), MessageCallback );
    }

    private void MessageCallback(
        IMessage message
    ) {
        switch( message.MessageType ) {
            case MessageType.PrivMsg:
                if( m_messages.Count > m_batchSize ) {
                    m_messages.Dequeue();
                }

                m_messages.Enqueue( (PrivMsg)message );
                StateHasChanged();
                break;
        }

    }

    private async Task HandleEnterPressed(
        string value
    ) {
        m_messages.Clear();

        GetUsersResponse response = await m_service.GetUsers( value );
        if( response.StatusCode == HttpStatusCode.OK ) {
            m_displayName = response.ApiResponse.Data[0].DisplayName;
            await m_service.DisconnectFromIrcChannel();
            await m_service.ConnectToIrcChannel( value, MessageCallback );
        }

        StateHasChanged();
    }
}